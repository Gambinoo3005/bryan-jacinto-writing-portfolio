---
// CardStack.astro - A deck of cards with arrow navigation
export interface Props {
  cards: Array<{
    id: string;
    title: string;
    description: string;
    company?: string;
    period?: string;
    location?: string;
    image?: string;
    link?: string;
  }>;
  cardWidth?: string;
  cardHeight?: string;
  stackShift?: number;
  stackScale?: number;
  enterRotation?: number;
  enterOpacity?: number;
  transitionDuration?: number;
}

const {
  cards,
  cardWidth = "400px",
  cardHeight = "300px",
  stackShift = 48,
  stackScale = 0.05,
  enterRotation = 6,
  enterOpacity = 0.7,
  transitionDuration = 400
} = Astro.props;

if (!cards || cards.length === 0) {
  throw new Error("CardStack requires at least one card");
}
---

<div class="card-stack-container" 
     data-card-width={cardWidth} 
     data-card-height={cardHeight}
     data-stack-shift={stackShift}
     data-stack-scale={stackScale}
     data-enter-rotation={enterRotation}
     data-enter-opacity={enterOpacity}
     data-transition-duration={transitionDuration}>
  <div class="card-stack-wrapper">
    <!-- Card Deck -->
    <div class="card-deck">
      {cards.map((card, index) => (
        <div 
          class={`card ${index === 0 ? 'card-active' : 'card-stacked'}`}
          data-index={index}
          data-card-id={card.id}
          style={`
            --stack-shift: ${stackShift}px;
            --stack-scale: ${stackScale};
            --enter-rotation: ${enterRotation}deg;
            --enter-opacity: ${enterOpacity};
            --transition-duration: ${transitionDuration}ms;
            --card-width: ${cardWidth};
            --card-height: ${cardHeight};
          `}
        >
          <div class="card-content">
            {card.image && (
              <div class="card-image">
                <img src={card.image} alt={card.title} />
              </div>
            )}
            <div class="card-body">
              <div class="card-header">
                <h3>{card.title}</h3>
                {card.company && (
                  <div class="card-meta">
                    <span class="card-company">{card.company}</span>
                    {card.period && <span class="card-period">{card.period}</span>}
                    {card.location && <span class="card-location">{card.location}</span>}
                  </div>
                )}
              </div>
              <p class="card-description">{card.description}</p>
            </div>
          </div>
        </div>
      ))}
    </div>

    <!-- Mobile Swipe Hint -->
    <div class="swipe-hint">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="5 12 12 12 12 5"></polyline>
        <path d="M12 12l7 7-7 7"></path>
      </svg>
      <span>Swipe to navigate</span>
    </div>

    <!-- Navigation Controls - Redesigned -->
    <div class="card-nav-controls">
      <button 
        class="card-nav-btn card-nav-prev" 
        aria-label="Previous experience"
        disabled
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      
      <div class="card-nav-indicator">
        <span class="current-position">1</span>
        <span class="nav-separator">/</span>
        <span class="total-cards">{cards.length}</span>
      </div>
      
      <button 
        class="card-nav-btn card-nav-next" 
        aria-label="Next experience"
        disabled={cards.length <= 1}
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </button>
    </div>
  </div>
</div>

<script>
  class CardStack {
    private container: HTMLElement;
    private cards: HTMLElement[];
    private prevButton: HTMLButtonElement;
    private nextButton: HTMLButtonElement;
    private positionIndicator: HTMLElement | null;
    private swipeHint: HTMLElement | null;
    private currentIndex: number;
    private totalCards: number;
    private hoveredCard: HTMLElement | null = null;
    private cardRandomOffsets: Array<{ x: number; y: number; rotation: number }> = [];

    constructor(container: HTMLElement) {
      this.container = container;
      this.cards = Array.from(container.querySelectorAll('.card')) as HTMLElement[];
      this.prevButton = container.querySelector('.card-nav-prev') as HTMLButtonElement;
      this.nextButton = container.querySelector('.card-nav-next') as HTMLButtonElement;
      this.positionIndicator = container.querySelector('.current-position');
      this.swipeHint = container.querySelector('.swipe-hint');
      this.currentIndex = 0;
      this.totalCards = this.cards.length;
      this.hoveredCard = null;
      
      // Generate random offsets for each card to create organic stack appearance
      this.cardRandomOffsets = this.cards.map(() => ({
        x: (Math.random() - 0.5) * 8, // Random x offset between -4px and 4px
        y: (Math.random() - 0.5) * 6, // Random y offset between -3px and 3px
        rotation: (Math.random() - 0.5) * 2 // Random rotation between -1deg and 1deg
      }));
      
      this.init();
    }

    init() {
      this.setupEventListeners();
      this.updateButtonStates();
      this.positionCards();
    }

    setupEventListeners() {
      this.prevButton.addEventListener('click', () => this.previousCard());
      this.nextButton.addEventListener('click', () => this.nextCard());
      
      // Keyboard support
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          this.previousCard();
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          this.nextCard();
        }
      });

      // Touch/swipe support for mobile
      let startX = 0;
      let startY = 0;
      
      this.container.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      });
      
      this.container.addEventListener('touchend', (e) => {
        if (!startX || !startY) return;
        
        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        
        const diffX = startX - endX;
        const diffY = startY - endY;
        
        // Only trigger if horizontal swipe is more significant than vertical
        if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
          if (diffX > 0) {
            // Swipe left - next card
            this.nextCard();
          } else {
            // Swipe right - previous card
            this.previousCard();
          }
        }
        
        startX = 0;
        startY = 0;
      });

      // Hover effect for stacked cards - pull upward like pulling from a deck
      this.cards.forEach((card: HTMLElement, index: number) => {
        card.addEventListener('mouseenter', () => {
          if (card.classList.contains('card-stacked')) {
            // Clear any previously hovered card first
            if (this.hoveredCard && this.hoveredCard !== card) {
              const prevIndex = this.cards.indexOf(this.hoveredCard);
              this.removeHoverEffect(this.hoveredCard, prevIndex);
            }
            // Apply hover effect to current card
            this.hoveredCard = card;
            this.applyHoverEffect(card, index);
          }
        });

        card.addEventListener('mouseleave', () => {
          if (card.classList.contains('card-stacked') && this.hoveredCard === card) {
            this.removeHoverEffect(card, index);
            this.hoveredCard = null;
          }
        });

        // Click functionality - bring clicked card to front
        card.addEventListener('click', () => {
          if (card.classList.contains('card-stacked')) {
            this.goToCard(index);
          }
        });
      });

      // Clear hover state when mouse leaves the entire card deck
      const cardDeck = this.container.querySelector('.card-deck');
      if (cardDeck) {
        cardDeck.addEventListener('mouseleave', () => {
          if (this.hoveredCard) {
            const hoveredIndex = this.cards.indexOf(this.hoveredCard);
            this.removeHoverEffect(this.hoveredCard, hoveredIndex);
            this.hoveredCard = null;
          }
        });
      }
    }

    applyHoverEffect(card: HTMLElement, index: number) {
      const distance = index - this.currentIndex;
      
      // Calculate transform values for hover state
      const offset = distance * this.getStackShift();
      const scale = Math.max(0.92, 1 - (Math.abs(distance) * this.getStackScale()));
      
      // Minimal pull - just enough to indicate hover
      const pullUpDistance = -12; // Minimal 12px pull
      const hoverScale = scale + 0.015; // Very subtle scale increase
      
      // Get random offsets for this card
      const randomOffset = this.cardRandomOffsets[index];
      const totalXOffset = offset + randomOffset.x;
      const totalYOffset = randomOffset.y + pullUpDistance;
      
      if (distance > 0) {
        // Future cards (right side)
        const rotation = this.getEnterRotation() * (1 - distance * 0.08);
        const totalRotation = rotation + randomOffset.rotation;
        card.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${totalYOffset}px) scale(${hoverScale}) rotate(${totalRotation}deg)`;
      } else {
        // Past cards (left side)
        const totalRotation = randomOffset.rotation;
        card.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${totalYOffset}px) scale(${hoverScale}) rotate(${totalRotation}deg)`;
      }
      
      // DON'T change z-index or opacity - maintain stack hierarchy and prevent transparency
      
      // Apply shadow and text visibility
      const cardContent = card.querySelector('.card-content') as HTMLElement;
      const cardBody = card.querySelector('.card-body') as HTMLElement;
      if (cardContent) {
        cardContent.style.boxShadow = 'none';
      }
      if (cardBody) {
        cardBody.style.opacity = '0.2';
      }
    }

    removeHoverEffect(card: HTMLElement, index: number) {
      const distance = index - this.currentIndex;
      
      // Restore original transform with random offsets
      const offset = distance * this.getStackShift();
      const scale = Math.max(0.92, 1 - (Math.abs(distance) * this.getStackScale()));
      
      // Get random offsets for this card
      const randomOffset = this.cardRandomOffsets[index];
      const totalXOffset = offset + randomOffset.x;
      
      if (distance > 0) {
        const rotation = this.getEnterRotation() * (1 - distance * 0.08);
        const totalRotation = rotation + randomOffset.rotation;
        card.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${randomOffset.y}px) scale(${scale}) rotate(${totalRotation}deg)`;
        card.style.opacity = '1'; // Keep fully opaque
        card.style.zIndex = (50 - distance).toString();
      } else {
        const totalRotation = randomOffset.rotation;
        card.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${randomOffset.y}px) scale(${scale}) rotate(${totalRotation}deg)`;
        card.style.opacity = '1'; // Keep fully opaque
        card.style.zIndex = (50 + distance).toString();
      }
      
      // Restore original shadow and text visibility
      const cardContent = card.querySelector('.card-content') as HTMLElement;
      const cardBody = card.querySelector('.card-body') as HTMLElement;
      if (cardContent) {
        cardContent.style.boxShadow = '';
      }
      if (cardBody) {
        cardBody.style.opacity = '';
      }
    }

    nextCard() {
      if (this.currentIndex < this.totalCards - 1) {
        this.hideSwipeHint();
        this.currentIndex++;
        this.updateCards();
        this.updateButtonStates();
      }
    }

    previousCard() {
      if (this.currentIndex > 0) {
        this.hideSwipeHint();
        this.currentIndex--;
        this.updateCards();
        this.updateButtonStates();
      }
    }

    hideSwipeHint() {
      if (this.swipeHint) {
        this.swipeHint.style.opacity = '0';
        this.swipeHint.style.pointerEvents = 'none';
        setTimeout(() => {
          if (this.swipeHint) {
            this.swipeHint.style.display = 'none';
          }
        }, 300);
      }
    }

    goToCard(index: number) {
      if (index >= 0 && index < this.totalCards && index !== this.currentIndex) {
        this.currentIndex = index;
        this.updateCards();
        this.updateButtonStates();
      }
    }

    updateCards() {
      // Clear any hover state when navigating
      if (this.hoveredCard) {
        this.hoveredCard = null;
      }
      
      this.cards.forEach((card: HTMLElement, index: number) => {
        const cardElement = card;
        const distance = index - this.currentIndex;
        
        // Remove all classes first
        cardElement.classList.remove('card-active', 'card-stacked', 'card-hidden', 'card-hidden-text');
        
        // Clear any inline styles from hover effects to prevent text color bugs
        const cardContent = card.querySelector('.card-content') as HTMLElement;
        const cardBody = card.querySelector('.card-body') as HTMLElement;
        if (cardContent) {
          cardContent.style.boxShadow = '';
        }
        if (cardBody) {
          cardBody.style.opacity = '';
        }
        
        // Cascading animation - each card animates based on its index position
        // This creates a consistent wave effect for EVERY navigation (nav buttons or click)
        const delay = index * 80; // Each card in the stack animates 80ms after the previous one
        
        if (distance === 0) {
          // Active card (centered)
          cardElement.classList.add('card-active');
          cardElement.style.transitionDelay = `${delay}ms`;
          cardElement.style.transform = 'translateX(-50%) scale(1) rotate(0deg)';
          cardElement.style.opacity = '1';
          cardElement.style.zIndex = '100';
         } else if (distance > 0) {
          // Future cards (right side, tilted) - hide text content
          cardElement.classList.add('card-stacked', 'card-hidden-text');
          const offset = distance * this.getStackShift();
          const scale = Math.max(0.92, 1 - (distance * this.getStackScale())); // Less aggressive scaling
          const rotation = this.getEnterRotation() * (1 - distance * 0.08); // Smoother rotation
          
          // Add random offsets for organic appearance
          const randomOffset = this.cardRandomOffsets[index];
          const totalXOffset = offset + randomOffset.x;
          const totalRotation = rotation + randomOffset.rotation;
          
          cardElement.style.transitionDelay = `${delay}ms`;
          cardElement.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${randomOffset.y}px) scale(${scale}) rotate(${totalRotation}deg)`;
          cardElement.style.opacity = '1'; // Fully opaque to prevent text bleeding
          cardElement.style.zIndex = (50 - distance).toString();
        } else {
          // Past cards (left side, stacked) - hide text content
          cardElement.classList.add('card-stacked', 'card-hidden-text');
          const offset = distance * this.getStackShift();
          const scale = Math.max(0.92, 1 - (Math.abs(distance) * this.getStackScale())); // Less aggressive scaling
          
          // Add random offsets for organic appearance
          const randomOffset = this.cardRandomOffsets[index];
          const totalXOffset = offset + randomOffset.x;
          const totalRotation = randomOffset.rotation;
          
          cardElement.style.transitionDelay = `${delay}ms`;
          cardElement.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${randomOffset.y}px) scale(${scale}) rotate(${totalRotation}deg)`;
          cardElement.style.opacity = '1'; // Fully opaque to prevent text bleeding
          cardElement.style.zIndex = (50 + distance).toString();
        }
      });

      // Reset transition delays after animation completes
      setTimeout(() => {
        this.cards.forEach((card: HTMLElement) => {
          card.style.transitionDelay = '0ms';
        });
      }, 600 + (this.cards.length * 80)); // Adjusted timing to match cascade effect
    }

    updateButtonStates() {
      this.prevButton.disabled = this.currentIndex === 0;
      this.nextButton.disabled = this.currentIndex === this.totalCards - 1;
      
      // Update position indicator
      if (this.positionIndicator) {
        this.positionIndicator.textContent = (this.currentIndex + 1).toString();
      }
    }

    positionCards() {
      this.updateCards();
    }

    getStackShift(): number {
      return parseInt(this.container.dataset.stackShift || '48');
    }

    getStackScale(): number {
      return parseFloat(this.container.dataset.stackScale || '0.05');
    }

    getEnterRotation(): number {
      return parseInt(this.container.dataset.enterRotation || '6');
    }

    getEnterOpacity(): number {
      return parseFloat(this.container.dataset.enterOpacity || '0.7');
    }
  }

  // Initialize all card stacks on the page
  document.addEventListener('DOMContentLoaded', () => {
    const cardStacks = document.querySelectorAll('.card-stack-container');
    cardStacks.forEach(container => {
      new CardStack(container as HTMLElement);
    });
  });
</script>

<style>
  .card-stack-container {
    --stack-shift: 60px;
    --stack-scale: 0.05;
    --enter-rotation: 6deg;
    --enter-opacity: 0.7;
    --transition-duration: 400ms;
    --card-width: 784px;
    --card-height: 343px;
    --shadow-active: none;
    --shadow-stacked: none;
  }

  /* Mobile-first responsive card dimensions */
  @media (max-width: 768px) {
    .card-stack-container {
      --card-width: calc(100vw - 3rem);
      --card-height: 320px;
      --stack-shift: 25px;
      --stack-scale: 0.06;
      --enter-rotation: 3deg;
    }
  }

  @media (max-width: 480px) {
    .card-stack-container {
      --card-width: calc(100vw - 2rem);
      --card-height: 300px;
      --stack-shift: 20px;
      --stack-scale: 0.08;
      --enter-rotation: 2deg;
    }
  }

  .card-stack-wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    padding: 1rem;
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
  }

  /* Swipe Hint - Mobile Only */
  .swipe-hint {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 0.625rem 1rem;
    background-color: var(--surface-glass);
    border: 1px solid var(--color-border);
    border-radius: 2rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--color-muted);
    margin-bottom: 0.5rem;
    animation: swipeHintPulse 2s ease-in-out infinite;
    transition: opacity 300ms ease, display 300ms ease;
    user-select: none;
  }

  @keyframes swipeHintPulse {
    0%, 100% {
      opacity: 0.6;
      transform: translateX(0);
    }
    50% {
      opacity: 1;
      transform: translateX(4px);
    }
  }

  @media (max-width: 768px) {
    .swipe-hint {
      display: flex;
    }
  }

  .card-nav-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1.5rem;
    z-index: 5;
    position: relative;
    margin-top: -35px;
  }

  /* Hide navigation controls on mobile */
  @media (max-width: 768px) {
    .card-nav-controls {
      display: none;
    }
  }

  .card-nav-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 52px;
    height: 52px;
    border-radius: 50%;
    background-color: var(--card-bg);
    border: 2px solid var(--color-border);
    color: var(--color-text);
    box-shadow: none;
    cursor: pointer;
    transition: all 250ms cubic-bezier(0.34, 1.56, 0.64, 1);
    position: relative;
    overflow: hidden;
  }

  .card-nav-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at center, var(--color-link) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 250ms ease;
  }

  .card-nav-btn:hover:not(:disabled) {
    background-color: var(--surface-glass-strong);
    border-color: var(--color-link);
    color: var(--color-link);
    transform: translateY(-2px) scale(1.05);
    box-shadow: none;
  }

  .card-nav-btn:hover:not(:disabled)::before {
    opacity: 0.06;
  }

  .card-nav-btn:active:not(:disabled) {
    transform: translateY(0) scale(0.98);
    box-shadow: none;
  }

  .card-nav-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    transform: scale(0.95);
  }

  .card-nav-btn:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px var(--color-bg), 0 0 0 5px var(--color-link);
  }

  .card-nav-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.25rem;
    background-color: var(--surface-glass);
    border: 1px solid var(--color-border);
    border-radius: 2rem;
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--color-text);
    box-shadow: none;
    user-select: none;
  }

  .current-position {
    color: var(--color-link);
    font-size: 1.1rem;
  }

  .nav-separator {
    opacity: 0.4;
  }

  .total-cards {
    opacity: 0.6;
  }

  .card-deck {
    position: relative;
    width: var(--card-width);
    height: var(--card-height);
    min-height: 320px;
    perspective: 1000px;
    touch-action: pan-y; /* Allow vertical scrolling but handle horizontal swipes */
    margin: 0 auto;
    max-width: calc(100vw - 2rem);
    overflow: visible; /* Allow cards to extend beyond deck for stacking effect */
    isolation: isolate;
    z-index: 10;
    /* Ensure proper stacking context */
    transform-style: preserve-3d;
    /* Ensure proper rendering of child elements */
    contain: none;
  }

  /* Mobile responsive adjustments */
  @media (max-width: 768px) {
    .card-deck {
      max-width: calc(100vw - 3rem);
      height: 320px;
      min-height: 320px;
    }
  }

  @media (max-width: 480px) {
    .card-deck {
      max-width: calc(100vw - 2rem);
      height: 300px;
      min-height: 300px;
    }
  }

  .card {
    position: absolute;
    top: 0;
    left: 50%;
    width: var(--card-width);
    height: var(--card-height);
    max-width: calc(100vw - 2rem);
    transform: translateX(-50%);
    transition: all 600ms cubic-bezier(0.34, 1.56, 0.64, 1);
    will-change: transform, opacity;
    isolation: isolate;
    /* Removed contain property to fix edge rendering issues */
    /* Improve text rendering during transforms */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Mobile responsive card adjustments */
  @media (max-width: 768px) {
    .card {
      max-width: calc(100vw - 3rem);
      height: 320px;
      min-height: 320px;
    }
  }

  @media (max-width: 480px) {
    .card {
      max-width: calc(100vw - 2rem);
      height: 300px;
      min-height: 300px;
    }
  }

  .card-content {
    width: 100%;
    height: 100%;
    background-color: var(--card-bg);
    border: 1px solid var(--color-border);
    border-radius: 16px;
    overflow: hidden; /* Keep hidden to maintain card boundaries */
    box-shadow: var(--shadow-stacked);
    transition: box-shadow 800ms cubic-bezier(0.16, 1, 0.3, 1);
    display: flex;
    flex-direction: column;
    will-change: box-shadow;
    isolation: isolate;
    position: relative;
    z-index: 1;
    /* Ensure proper border rendering */
    box-sizing: border-box;
    /* Add subtle outline to ensure edges are visible */
    outline: 1px solid transparent;
    outline-offset: -1px;
  }

  .card-active .card-content {
    box-shadow: var(--shadow-active);
  }

  /* Ensure card borders are always visible with pseudo-element */
  .card-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 1px solid var(--color-border);
    border-radius: 16px;
    pointer-events: none;
    z-index: 1;
  }

  /* Hide all text content on stacked cards while keeping card structure visible */
  .card-hidden-text .card-body {
    opacity: 0;
    transition: opacity 400ms ease;
  }

  .card-active .card-body {
    opacity: 1;
    transition: opacity 400ms ease;
  }

  /* Ensure card structure remains visible even when text is hidden */
  .card-hidden-text .card-content {
    background-color: var(--card-bg);
    border: 1px solid var(--color-border);
    /* Add subtle visual depth for stacked cards */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  /* Active card hover - simple lift */
  .card-active:hover {
    transform: translateX(-50%) translateY(-3px) scale(1) rotate(0deg) !important;
    transition: transform 200ms cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 200ms ease !important;
  }

  .card-active:hover .card-content {
    box-shadow: none !important;
  }

  /* Stacked cards - smooth transitions (hover effects handled by JavaScript) */
  .card-stacked {
    transition: transform 200ms cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                box-shadow 200ms ease,
                opacity 200ms ease;
    cursor: pointer; /* Indicate that stacked cards are clickable */
  }

  /* Active card has default cursor */
  .card-active {
    cursor: default;
  }

  .card-image {
    width: 100%;
    height: 40%;
    overflow: hidden;
  }

  .card-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 600ms cubic-bezier(0.25, 0.46, 0.45, 0.94);
    will-change: transform;
  }

  .card-active .card-image img {
    transform: scale(1.02);
  }

  .card-body {
    flex: 1;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    position: relative;
    z-index: 2; /* Above the pseudo-element border */
    background-color: var(--card-bg);
    /* Ensure content fits within card boundaries */
    overflow: hidden;
    box-sizing: border-box;
    /* Improve text rendering during hover transforms */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
    backface-visibility: hidden;
    transform: translateZ(0); /* Force hardware acceleration */
    min-height: 0; /* Allow flex shrinking */
  }

  /* Mobile responsive card body adjustments */
  @media (max-width: 768px) {
    .card-body {
      padding: 1.25rem;
    }
  }

  @media (max-width: 480px) {
    .card-body {
      padding: 1rem;
    }
  }

  .card-header {
    margin-bottom: 1rem;
  }

  .card-title {
    font-size: 1.75rem;
    font-weight: 700;
    color: var(--color-heading);
    margin: 0 0 1rem 0;
    line-height: 1.3;
    /* Prevent text blurriness during hover */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Mobile responsive title adjustments */
  @media (max-width: 768px) {
    .card-title {
      font-size: 1.375rem;
      margin-bottom: 0.625rem;
    }
  }

  @media (max-width: 480px) {
    .card-title {
      font-size: 1.25rem;
      margin-bottom: 0.5rem;
      line-height: 1.25;
    }
  }

  .card-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
    margin-top: 0.75rem;
    margin-bottom: 0.5rem;
  }

  .card-company {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--color-link);
    background-color: var(--surface-glass);
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    border: 1px solid var(--color-border);
  }

  .card-period {
    font-size: 1rem;
    color: var(--color-muted);
    font-weight: 500;
  }

  .card-location {
    font-size: 1rem;
    color: var(--color-muted);
    font-weight: 500;
  }

  .card-description {
    font-size: 1.125rem;
    color: var(--color-muted);
    line-height: 1.6;
    margin: 0 0 1.5rem 0;
    flex: 1;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
    /* Prevent text blurriness during hover */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Mobile responsive description adjustments */
  @media (max-width: 768px) {
    .card-description {
      font-size: 0.9375rem;
      line-height: 1.5;
      margin-bottom: 0.875rem;
      -webkit-line-clamp: 3;
    }
  }

  @media (max-width: 480px) {
    .card-description {
      font-size: 0.875rem;
      line-height: 1.45;
      margin-bottom: 0.625rem;
      -webkit-line-clamp: 2;
    }
  }


  .card-stack-indicator {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background-color: var(--surface-glass);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--color-muted);
    backdrop-filter: blur(8px);
  }

  .stack-count {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .stack-count::before {
    content: "📚";
    font-size: 0.875rem;
  }

  /* Responsive adjustments */
  @media (max-width: 1200px) {
    .card-stack-wrapper {
      padding: 1.5rem;
    }
  }

  @media (max-width: 768px) {
    .card-stack-wrapper {
      padding: 0.5rem;
      gap: 2rem;
    }

    .card-company {
      font-size: 0.9375rem;
      padding: 0.4rem 0.75rem;
    }

    .card-period,
    .card-location {
      font-size: 0.875rem;
    }

    .card-nav-btn {
      width: 50px;
      height: 50px;
    }

    .card-nav-indicator {
      padding: 0.625rem 1rem;
      font-size: 0.875rem;
    }

    .card-nav-controls {
      gap: 1.25rem;
      margin-top: -25px;
    }
  }

  @media (max-width: 480px) {
    .card-stack-wrapper {
      padding: 0.25rem;
      gap: 1.75rem;
    }

    .card-company {
      font-size: 0.875rem;
      padding: 0.35rem 0.65rem;
    }

    .card-period,
    .card-location {
      font-size: 0.8125rem;
    }

    .card-nav-btn {
      width: 46px;
      height: 46px;
    }

    .card-nav-btn svg {
      width: 22px;
      height: 22px;
    }

    .card-nav-indicator {
      padding: 0.5rem 0.875rem;
      font-size: 0.8125rem;
    }

    .card-nav-controls {
      gap: 1rem;
      margin-top: -20px;
    }
  }

  /* Extra small screens */
  @media (max-width: 360px) {
    .card-company {
      font-size: 0.9rem;
      padding: 0.3rem 0.6rem;
    }

    .card-period,
    .card-location {
      font-size: 0.85rem;
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .card {
      transition: opacity var(--transition-duration) ease;
    }
    
    .card-content {
      transition: box-shadow var(--transition-duration) ease;
    }
  }
</style>
