---
// CardStack.astro - A deck of cards with arrow navigation
export interface Props {
  cards: Array<{
    id: string;
    title: string;
    description: string;
    company?: string;
    period?: string;
    location?: string;
    image?: string;
    link?: string;
  }>;
  cardWidth?: string;
  cardHeight?: string;
  stackShift?: number;
  stackScale?: number;
  enterRotation?: number;
  enterOpacity?: number;
  transitionDuration?: number;
}

const {
  cards,
  cardWidth = "400px",
  cardHeight = "300px",
  stackShift = 48,
  stackScale = 0.05,
  enterRotation = 6,
  enterOpacity = 0.7,
  transitionDuration = 400
} = Astro.props;

if (!cards || cards.length === 0) {
  throw new Error("CardStack requires at least one card");
}
---

<div class="card-stack-container" 
     data-card-width={cardWidth} 
     data-card-height={cardHeight}
     data-stack-shift={stackShift}
     data-stack-scale={stackScale}
     data-enter-rotation={enterRotation}
     data-enter-opacity={enterOpacity}
     data-transition-duration={transitionDuration}>
  <div class="card-stack-wrapper">
    <!-- Card Deck -->
    <div class="card-deck">
      {cards.map((card, index) => (
        <div 
          class={`card ${index === 0 ? 'card-active' : 'card-stacked'}`}
          data-index={index}
          data-card-id={card.id}
          style={`
            --stack-shift: ${stackShift}px;
            --stack-scale: ${stackScale};
            --enter-rotation: ${enterRotation}deg;
            --enter-opacity: ${enterOpacity};
            --transition-duration: ${transitionDuration}ms;
            --card-width: ${cardWidth};
            --card-height: ${cardHeight};
          `}
        >
          <div class="card-content">
            {card.image && (
              <div class="card-image">
                <img src={card.image} alt={card.title} />
              </div>
            )}
            <div class="card-body">
              <div class="card-header">
                <h3>{card.title}</h3>
                {card.company && (
                  <div class="card-meta">
                    <span class="card-company">{card.company}</span>
                    {card.period && <span class="card-period">{card.period}</span>}
                    {card.location && <span class="card-location">{card.location}</span>}
                  </div>
                )}
              </div>
              <p class="card-description">{card.description}</p>
            </div>
          </div>
        </div>
      ))}
    </div>

    <!-- Mobile Swipe Hint -->
    <div class="swipe-hint">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="5 12 12 12 12 5"></polyline>
        <path d="M12 12l7 7-7 7"></path>
      </svg>
      <span>Swipe to navigate</span>
    </div>

    <!-- Navigation Controls - Arrows and Dots -->
    <div class="card-nav-controls">
      <button 
        class="card-nav-btn card-nav-prev" 
        aria-label="Previous experience"
        disabled
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      
      <!-- Dot Indicators -->
      <div class="card-dots">
        {cards.map((_, index) => (
          <button 
            class={`card-dot ${index === 0 ? 'active' : ''}`}
            data-index={index}
            aria-label={`Go to experience ${index + 1}`}
          ></button>
        ))}
      </div>
      
      <button 
        class="card-nav-btn card-nav-next" 
        aria-label="Next experience"
        disabled={cards.length <= 1}
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </button>
    </div>
  </div>
</div>

<script>
  // Prevent script from running multiple times during hot reload
  if (!(window as any).__CARD_STACK_SCRIPT_LOADED__) {
    (window as any).__CARD_STACK_SCRIPT_LOADED__ = true;
  
  // Simple singleton pattern to prevent duplicate initialization
  const CARD_STACK_INITIALIZED = Symbol('cardStackInitialized');

  class CardStack {
    private container: HTMLElement;
    private cards: HTMLElement[];
    private prevButton: HTMLButtonElement;
    private nextButton: HTMLButtonElement;
    private dots: NodeListOf<HTMLButtonElement>;
    private swipeHint: HTMLElement | null;
    private _currentIndex: number = 0;
    private totalCards: number;
    private hoveredCard: HTMLElement | null = null;
    private cardRandomOffsets: Array<{ x: number; y: number; rotation: number }> = [];
    private isTransitioning: boolean = false;

    // Getter/setter for currentIndex with automatic UI update
    private get currentIndex(): number {
      return this._currentIndex;
    }

    private set currentIndex(value: number) {
      // Clamp value to valid range
      const newIndex = Math.max(0, Math.min(value, this.totalCards - 1));
      
      // Only update if value actually changed
      if (this._currentIndex !== newIndex) {
        this._currentIndex = newIndex;
        this.updateDots();
      }
    }

    constructor(container: HTMLElement) {
      this.container = container;
      this.cards = Array.from(container.querySelectorAll('.card')) as HTMLElement[];
      this.prevButton = container.querySelector('.card-nav-prev') as HTMLButtonElement;
      this.nextButton = container.querySelector('.card-nav-next') as HTMLButtonElement;
      this.dots = container.querySelectorAll('.card-dot');
      this.swipeHint = container.querySelector('.swipe-hint');
      this.totalCards = this.cards.length;
      this.hoveredCard = null;
      this.isTransitioning = false;
      
      // Generate random offsets for each card to create organic stack appearance
      this.cardRandomOffsets = this.cards.map(() => ({
        x: (Math.random() - 0.5) * 8,
        y: (Math.random() - 0.5) * 6,
        rotation: (Math.random() - 0.5) * 2
      }));
      
      this.init();
    }

    init() {
      this.setupEventListeners();
      this.updateDots();
      this.updateButtonStates();
      this.positionCards();
    }

    // Dedicated method to update dot indicators
    private updateDots() {
      this.dots.forEach((dot, index) => {
        if (index === this._currentIndex) {
          dot.classList.add('active');
        } else {
          dot.classList.remove('active');
        }
      });
    }

    setupEventListeners() {
      // Button navigation
      this.prevButton.addEventListener('click', () => this.navigate(-1));
      this.nextButton.addEventListener('click', () => this.navigate(1));
      
      // Dot navigation
      this.dots.forEach((dot, index) => {
        dot.addEventListener('click', () => this.goToIndex(index));
      });
      
      // Keyboard support - only when hovering over card stack
      let isHovered = false;
      
      this.container.addEventListener('mouseenter', () => { isHovered = true; });
      this.container.addEventListener('mouseleave', () => { isHovered = false; });
      
      document.addEventListener('keydown', (e) => {
        if (!isHovered || this.isTransitioning) return;
        
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          this.navigate(-1);
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          this.navigate(1);
        }
      });

      // Touch/swipe support for mobile - improved
      let startX = 0;
      let startY = 0;
      let isSwiping = false;
      
      this.container.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        isSwiping = false;
      }, { passive: true });
      
      this.container.addEventListener('touchmove', (e) => {
        if (!startX || !startY) return;
        
        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;
        
        const diffX = Math.abs(startX - currentX);
        const diffY = Math.abs(startY - currentY);
        
        // If horizontal movement is greater than vertical, prevent scroll
        if (diffX > diffY && diffX > 10) {
          isSwiping = true;
          e.preventDefault();
        }
      }, { passive: false });
      
      this.container.addEventListener('touchend', (e) => {
        if (!startX || !startY) return;
        
        const endX = e.changedTouches[0].clientX;
        const diffX = startX - endX;
        const diffY = startY - e.changedTouches[0].clientY;
        
        // Only trigger if horizontal swipe and not transitioning
        if (!this.isTransitioning && isSwiping && Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 40) {
          this.navigate(diffX > 0 ? 1 : -1);
        }
        
        startX = 0;
        startY = 0;
        isSwiping = false;
      }, { passive: true });

      // Hover effect for stacked cards - pull upward like pulling from a deck
      this.cards.forEach((card: HTMLElement, index: number) => {
        card.addEventListener('mouseenter', () => {
          if (card.classList.contains('card-stacked')) {
            // Clear any previously hovered card first
            if (this.hoveredCard && this.hoveredCard !== card) {
              const prevIndex = this.cards.indexOf(this.hoveredCard);
              this.removeHoverEffect(this.hoveredCard, prevIndex);
            }
            // Apply hover effect to current card
            this.hoveredCard = card;
            this.applyHoverEffect(card, index);
          }
        });

        card.addEventListener('mouseleave', () => {
          if (card.classList.contains('card-stacked') && this.hoveredCard === card) {
            this.removeHoverEffect(card, index);
            this.hoveredCard = null;
          }
        });

        // Click functionality - bring clicked card to front
        card.addEventListener('click', () => {
          if (!this.isTransitioning && card.classList.contains('card-stacked')) {
            this.goToIndex(index);
          }
        });
      });

      // Clear hover state when mouse leaves the entire card deck
      const cardDeck = this.container.querySelector('.card-deck');
      if (cardDeck) {
        cardDeck.addEventListener('mouseleave', () => {
          if (this.hoveredCard) {
            const hoveredIndex = this.cards.indexOf(this.hoveredCard);
            this.removeHoverEffect(this.hoveredCard, hoveredIndex);
            this.hoveredCard = null;
          }
        });
      }
    }

    applyHoverEffect(card: HTMLElement, index: number) {
      const distance = index - this._currentIndex;
      
      // Calculate transform values for hover state
      const offset = distance * this.getStackShift();
      const scale = Math.max(0.92, 1 - (Math.abs(distance) * this.getStackScale()));
      
      // Minimal pull - just enough to indicate hover
      const pullUpDistance = -12; // Minimal 12px pull
      const hoverScale = scale + 0.015; // Very subtle scale increase
      
      // Get random offsets for this card
      const randomOffset = this.cardRandomOffsets[index];
      const totalXOffset = offset + randomOffset.x;
      const totalYOffset = randomOffset.y + pullUpDistance;
      
      if (distance > 0) {
        // Future cards (right side)
        const rotation = this.getEnterRotation() * (1 - distance * 0.08);
        const totalRotation = rotation + randomOffset.rotation;
        card.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${totalYOffset}px) scale(${hoverScale}) rotate(${totalRotation}deg)`;
      } else {
        // Past cards (left side)
        const totalRotation = randomOffset.rotation;
        card.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${totalYOffset}px) scale(${hoverScale}) rotate(${totalRotation}deg)`;
      }
      
      // DON'T change z-index or opacity - maintain stack hierarchy and prevent transparency
      
      // Apply shadow and text visibility
      const cardContent = card.querySelector('.card-content') as HTMLElement;
      const cardBody = card.querySelector('.card-body') as HTMLElement;
      if (cardContent) {
        cardContent.style.boxShadow = 'none';
      }
      if (cardBody) {
        cardBody.style.opacity = '0.2';
      }
    }

    removeHoverEffect(card: HTMLElement, index: number) {
      const distance = index - this._currentIndex;
      
      // Restore original transform with random offsets
      const offset = distance * this.getStackShift();
      const scale = Math.max(0.92, 1 - (Math.abs(distance) * this.getStackScale()));
      
      // Get random offsets for this card
      const randomOffset = this.cardRandomOffsets[index];
      const totalXOffset = offset + randomOffset.x;
      
      if (distance > 0) {
        const rotation = this.getEnterRotation() * (1 - distance * 0.08);
        const totalRotation = rotation + randomOffset.rotation;
        card.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${randomOffset.y}px) scale(${scale}) rotate(${totalRotation}deg)`;
        card.style.opacity = '1'; // Keep fully opaque
        card.style.zIndex = (50 - distance).toString();
      } else {
        const totalRotation = randomOffset.rotation;
        card.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${randomOffset.y}px) scale(${scale}) rotate(${totalRotation}deg)`;
        card.style.opacity = '1'; // Keep fully opaque
        card.style.zIndex = (50 + distance).toString();
      }
      
      // Restore original shadow and text visibility
      const cardContent = card.querySelector('.card-content') as HTMLElement;
      const cardBody = card.querySelector('.card-body') as HTMLElement;
      if (cardContent) {
        cardContent.style.boxShadow = '';
      }
      if (cardBody) {
        cardBody.style.opacity = '';
      }
    }

    // Unified navigation method
    navigate(direction: number) {
      if (this.isTransitioning) return;
      
      const newIndex = this._currentIndex + direction;
      if (newIndex >= 0 && newIndex < this.totalCards) {
        this.isTransitioning = true;
        this.hideSwipeHint();
        
        // Set new index (triggers automatic display update via setter)
        this.currentIndex = newIndex;
        
        // Update visuals
        this.updateButtonStates();
        this.updateCards();
        
        // Release lock after animation
        setTimeout(() => {
          this.isTransitioning = false;
        }, 400);
      }
    }

    // Jump to specific index
    goToIndex(targetIndex: number) {
      if (this.isTransitioning) return;
      if (targetIndex < 0 || targetIndex >= this.totalCards || targetIndex === this._currentIndex) return;
      
      this.isTransitioning = true;
      this.hideSwipeHint();
      
      // Set new index (triggers automatic display update via setter)
      this.currentIndex = targetIndex;
      
      // Update visuals
      this.updateButtonStates();
      this.updateCards();
      
      // Release lock after animation
      setTimeout(() => {
        this.isTransitioning = false;
      }, 400);
    }

    hideSwipeHint() {
      if (this.swipeHint) {
        this.swipeHint.style.opacity = '0';
        this.swipeHint.style.pointerEvents = 'none';
        setTimeout(() => {
          if (this.swipeHint) {
            this.swipeHint.style.display = 'none';
          }
        }, 300);
      }
    }

    updateCards() {
      // Clear any hover state when navigating
      if (this.hoveredCard) {
        this.hoveredCard = null;
      }
      
      this.cards.forEach((card: HTMLElement, index: number) => {
        const cardElement = card;
        const distance = index - this._currentIndex;
        
        // Clear any inline styles from hover effects to prevent text color bugs
        const cardContent = card.querySelector('.card-content') as HTMLElement;
        const cardBody = card.querySelector('.card-body') as HTMLElement;
        if (cardContent) {
          cardContent.style.boxShadow = '';
        }
        if (cardBody) {
          cardBody.style.opacity = '';
        }
        
        // Apply classes immediately without delay for instant visibility
        cardElement.classList.remove('card-active', 'card-stacked', 'card-hidden', 'card-hidden-text');
        
        if (distance === 0) {
          // Active card (centered) - show immediately
          cardElement.classList.add('card-active');
          cardElement.style.transitionDelay = '0ms';
          cardElement.style.transform = 'translateX(-50%) scale(1) rotate(0deg)';
          cardElement.style.opacity = '1';
          cardElement.style.zIndex = '100';
         } else if (distance > 0) {
          // Future cards (right side, tilted) - hide text content
          cardElement.classList.add('card-stacked', 'card-hidden-text');
          const offset = distance * this.getStackShift();
          const scale = Math.max(0.92, 1 - (distance * this.getStackScale()));
          const rotation = this.getEnterRotation() * (1 - distance * 0.08);
          
          // Add random offsets for organic appearance
          const randomOffset = this.cardRandomOffsets[index];
          const totalXOffset = offset + randomOffset.x;
          const totalRotation = rotation + randomOffset.rotation;
          
          cardElement.style.transitionDelay = '0ms';
          cardElement.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${randomOffset.y}px) scale(${scale}) rotate(${totalRotation}deg)`;
          cardElement.style.opacity = '1';
          cardElement.style.zIndex = (50 - distance).toString();
        } else {
          // Past cards (left side, stacked) - hide text content
          cardElement.classList.add('card-stacked', 'card-hidden-text');
          const offset = distance * this.getStackShift();
          const scale = Math.max(0.92, 1 - (Math.abs(distance) * this.getStackScale()));
          
          // Add random offsets for organic appearance
          const randomOffset = this.cardRandomOffsets[index];
          const totalXOffset = offset + randomOffset.x;
          const totalRotation = randomOffset.rotation;
          
          cardElement.style.transitionDelay = '0ms';
          cardElement.style.transform = `translateX(calc(-50% + ${totalXOffset}px)) translateY(${randomOffset.y}px) scale(${scale}) rotate(${totalRotation}deg)`;
          cardElement.style.opacity = '1';
          cardElement.style.zIndex = (50 + distance).toString();
        }
      });
    }

    updateButtonStates() {
      // Disable buttons only when at boundaries
      this.prevButton.disabled = this._currentIndex === 0;
      this.nextButton.disabled = this._currentIndex === this.totalCards - 1;
    }

    positionCards() {
      this.updateCards();
    }

    getStackShift(): number {
      return parseInt(this.container.dataset.stackShift || '48');
    }

    getStackScale(): number {
      return parseFloat(this.container.dataset.stackScale || '0.05');
    }

    getEnterRotation(): number {
      return parseInt(this.container.dataset.enterRotation || '6');
    }

    getEnterOpacity(): number {
      return parseFloat(this.container.dataset.enterOpacity || '0.7');
    }
  }

  // Initialize all card stacks on the page
  function initializeCardStacks() {
    const cardStacks = document.querySelectorAll('.card-stack-container');
    
    cardStacks.forEach(container => {
      const containerElement = container as HTMLElement;
      
      // Skip if already initialized
      if ((containerElement as any)[CARD_STACK_INITIALIZED]) {
        return;
      }
      
      // Mark as initialized and create instance
      (containerElement as any)[CARD_STACK_INITIALIZED] = true;
      new CardStack(containerElement);
    });
  }
  
  // Run initialization once DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeCardStacks);
  } else {
    initializeCardStacks();
  }
  
  } // End of script guard
</script>

<style>
  .card-stack-container {
    --stack-shift: 60px;
    --stack-scale: 0.05;
    --enter-rotation: 6deg;
    --enter-opacity: 0.7;
    --transition-duration: 400ms;
    --card-width: 784px;
    --card-height: 343px;
    --shadow-active: none;
    --shadow-stacked: none;
    /* Ensure proper touch handling */
    touch-action: pan-y pinch-zoom;
    -webkit-user-select: none;
    user-select: none;
  }

  /* Mobile-first responsive card dimensions */
  @media (max-width: 768px) {
    .card-stack-container {
      --card-width: calc(100vw - 3rem);
      --card-height: 320px;
      --stack-shift: 25px;
      --stack-scale: 0.06;
      --enter-rotation: 3deg;
    }
  }

  @media (max-width: 480px) {
    .card-stack-container {
      --card-width: calc(100vw - 2rem);
      --card-height: 300px;
      --stack-shift: 20px;
      --stack-scale: 0.08;
      --enter-rotation: 2deg;
    }
  }

  .card-stack-wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    padding: 0;
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
  }

  /* Swipe Hint - Mobile Only */
  .swipe-hint {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 0.625rem 1rem;
    background-color: var(--surface-glass);
    border: 1px solid var(--color-border);
    border-radius: 2rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--color-muted);
    margin-bottom: 0.5rem;
    animation: swipeHintPulse 2s ease-in-out infinite;
    transition: opacity 300ms ease, display 300ms ease;
    user-select: none;
  }

  @keyframes swipeHintPulse {
    0%, 100% {
      opacity: 0.6;
      transform: translateX(0);
    }
    50% {
      opacity: 1;
      transform: translateX(4px);
    }
  }

  @media (max-width: 768px) {
    .swipe-hint {
      display: flex;
    }
  }

  .card-nav-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1.5rem;
    z-index: 5;
    position: relative;
    margin-top: -35px;
  }

  /* Hide navigation controls on mobile */
  @media (max-width: 768px) {
    .card-nav-controls {
      display: none;
    }
  }

  .card-nav-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 52px;
    height: 52px;
    border-radius: 50%;
    background-color: var(--card-bg);
    border: 2px solid var(--color-border);
    color: var(--color-text);
    box-shadow: none;
    cursor: pointer;
    transition: all 250ms cubic-bezier(0.34, 1.56, 0.64, 1);
    position: relative;
    overflow: hidden;
  }

  .card-nav-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at center, var(--color-link) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 250ms ease;
  }

  .card-nav-btn:hover:not(:disabled) {
    background-color: var(--surface-glass-strong);
    border-color: var(--color-link);
    color: var(--color-link);
    transform: translateY(-2px) scale(1.05);
    box-shadow: none;
  }

  .card-nav-btn:hover:not(:disabled)::before {
    opacity: 0.06;
  }

  .card-nav-btn:active:not(:disabled) {
    transform: translateY(0) scale(0.98);
    box-shadow: none;
  }

  .card-nav-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    transform: scale(0.95);
  }

  .card-nav-btn:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px var(--color-bg), 0 0 0 5px var(--color-link);
  }

  .card-dots {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background-color: var(--surface-glass);
    border: 1px solid var(--color-border);
    border-radius: 2rem;
    user-select: none;
  }

  .card-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--color-border);
    border: none;
    cursor: pointer;
    transition: all 250ms cubic-bezier(0.34, 1.56, 0.64, 1);
    padding: 0;
  }

  .card-dot:hover {
    background-color: var(--color-text);
    transform: scale(1.2);
    opacity: 0.8;
  }

  .card-dot.active {
    background-color: var(--color-link);
    width: 24px;
    border-radius: 4px;
    transform: scale(1);
  }

  .card-dot:focus-visible {
    outline: 2px solid var(--color-link);
    outline-offset: 2px;
  }

  .card-deck {
    position: relative;
    width: var(--card-width);
    height: var(--card-height);
    min-height: 320px;
    perspective: 1000px;
    touch-action: pan-y pinch-zoom; /* Allow vertical scrolling and pinch zoom, handle horizontal swipes in JS */
    margin: 0 auto;
    max-width: calc(100vw - 2rem);
    overflow: visible; /* Allow cards to extend beyond deck for stacking effect */
    isolation: isolate;
    z-index: 10;
    /* Ensure proper stacking context */
    transform-style: preserve-3d;
    /* Ensure proper rendering of child elements */
    contain: none;
    /* Prevent momentum scrolling interference */
    -webkit-overflow-scrolling: auto;
  }

  /* Mobile responsive adjustments */
  @media (max-width: 768px) {
    .card-deck {
      max-width: calc(100vw - 3rem);
      height: 320px;
      min-height: 320px;
    }
  }

  @media (max-width: 480px) {
    .card-deck {
      max-width: calc(100vw - 2rem);
      height: 300px;
      min-height: 300px;
    }
  }

  .card {
    position: absolute;
    top: 0;
    left: 50%;
    width: var(--card-width);
    height: var(--card-height);
    max-width: calc(100vw - 2rem);
    transform: translateX(-50%);
    transition: all 600ms cubic-bezier(0.34, 1.56, 0.64, 1);
    will-change: transform, opacity;
    isolation: isolate;
    /* Removed contain property to fix edge rendering issues */
    /* Improve text rendering during transforms */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Mobile responsive card adjustments */
  @media (max-width: 768px) {
    .card {
      max-width: calc(100vw - 3rem);
      height: 320px;
      min-height: 320px;
    }
  }

  @media (max-width: 480px) {
    .card {
      max-width: calc(100vw - 2rem);
      height: 300px;
      min-height: 300px;
    }
  }

  .card-content {
    width: 100%;
    height: 100%;
    background-color: var(--card-bg);
    border: 1px solid var(--color-border);
    border-radius: 16px;
    overflow: hidden; /* Keep hidden to maintain card boundaries */
    box-shadow: 
      0 1px 3px rgba(0, 0, 0, 0.05),
      0 0 0 1px rgba(0, 0, 0, 0.02) inset;
    transition: all 600ms cubic-bezier(0.16, 1, 0.3, 1);
    display: flex;
    flex-direction: column;
    will-change: box-shadow, transform;
    isolation: isolate;
    position: relative;
    z-index: 1;
    box-sizing: border-box;
    /* Polished glass effect with inner highlight */
    background-image: 
      linear-gradient(to bottom, 
        rgba(255, 255, 255, 0.02) 0%, 
        transparent 50%
      );
  }
  
  /* Dark mode card adjustments */
  .dark .card-content {
    box-shadow: 
      0 1px 3px rgba(0, 0, 0, 0.3),
      0 0 0 1px rgba(255, 255, 255, 0.03) inset;
    background-image: 
      linear-gradient(to bottom, 
        rgba(255, 255, 255, 0.03) 0%, 
        transparent 50%
      );
  }

  .card-active .card-content {
    box-shadow: 
      0 8px 30px rgba(0, 0, 0, 0.12),
      0 2px 8px rgba(0, 0, 0, 0.08),
      0 0 0 1px rgba(0, 0, 0, 0.03) inset;
    transform: scale(1.01);
  }
  
  .dark .card-active .card-content {
    box-shadow: 
      0 8px 30px rgba(0, 0, 0, 0.5),
      0 2px 8px rgba(0, 0, 0, 0.3),
      0 0 0 1px rgba(255, 255, 255, 0.05) inset;
  }

  /* Ensure card borders are always visible with subtle glow */
  .card-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 1px solid var(--color-border);
    border-radius: 16px;
    pointer-events: none;
    z-index: 1;
    opacity: 0.8;
  }
  
  .card-active .card-content::before {
    opacity: 1;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05);
  }
  
  .dark .card-active .card-content::before {
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.08);
  }

  /* Hide all text content on stacked cards while keeping card structure visible */
  .card-hidden-text .card-body {
    opacity: 0;
    transition: opacity 150ms ease;
    pointer-events: none;
  }

  .card-active .card-body {
    opacity: 1;
    transition: opacity 250ms ease 100ms;
    pointer-events: auto;
  }

  /* Ensure card structure remains visible even when text is hidden */
  .card-hidden-text .card-content {
    background-color: var(--card-bg);
    border: 1px solid var(--color-border);
    /* Add subtle visual depth for stacked cards */
    box-shadow: 
      0 2px 8px rgba(0, 0, 0, 0.08),
      0 1px 3px rgba(0, 0, 0, 0.06),
      0 0 0 1px rgba(0, 0, 0, 0.02) inset;
  }
  
  .dark .card-hidden-text .card-content {
    box-shadow: 
      0 2px 8px rgba(0, 0, 0, 0.3),
      0 1px 3px rgba(0, 0, 0, 0.2),
      0 0 0 1px rgba(255, 255, 255, 0.02) inset;
  }

  /* Active card hover - enhanced lift with shadow */
  .card-active:hover {
    transform: translateX(-50%) translateY(-5px) scale(1.005) rotate(0deg) !important;
    transition: transform 250ms cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
  }

  .card-active:hover .card-content {
    box-shadow: 
      0 12px 40px rgba(0, 0, 0, 0.15),
      0 4px 12px rgba(0, 0, 0, 0.1),
      0 0 0 1px rgba(0, 0, 0, 0.04) inset !important;
  }
  
  .dark .card-active:hover .card-content {
    box-shadow: 
      0 12px 40px rgba(0, 0, 0, 0.6),
      0 4px 12px rgba(0, 0, 0, 0.4),
      0 0 0 1px rgba(255, 255, 255, 0.06) inset !important;
  }

  /* Stacked cards - smooth transitions (hover effects handled by JavaScript) */
  .card-stacked {
    transition: transform 200ms cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                box-shadow 200ms ease,
                opacity 200ms ease;
    cursor: pointer; /* Indicate that stacked cards are clickable */
  }

  /* Active card has default cursor */
  .card-active {
    cursor: default;
  }

  .card-image {
    width: 100%;
    height: 40%;
    overflow: hidden;
  }

  .card-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 600ms cubic-bezier(0.25, 0.46, 0.45, 0.94);
    will-change: transform;
  }

  .card-active .card-image img {
    transform: scale(1.02);
  }

  .card-body {
    flex: 1;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    position: relative;
    z-index: 2; /* Above the pseudo-element border */
    background-color: var(--card-bg);
    /* Ensure content fits within card boundaries */
    overflow: hidden;
    box-sizing: border-box;
    /* Improve text rendering during hover transforms */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
    backface-visibility: hidden;
    transform: translateZ(0); /* Force hardware acceleration */
    min-height: 0; /* Allow flex shrinking */
  }

  /* Mobile responsive card body adjustments */
  @media (max-width: 768px) {
    .card-body {
      padding: 1.25rem;
    }
  }

  @media (max-width: 480px) {
    .card-body {
      padding: 1rem;
    }
  }

  .card-header {
    margin-bottom: 1rem;
  }

  .card-title {
    font-size: 1.75rem;
    font-weight: 700;
    color: var(--color-heading);
    margin: 0 0 1rem 0;
    line-height: 1.3;
    /* Prevent text blurriness during hover */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Mobile responsive title adjustments */
  @media (max-width: 768px) {
    .card-title {
      font-size: 1.375rem;
      margin-bottom: 0.625rem;
    }
  }

  @media (max-width: 480px) {
    .card-title {
      font-size: 1.25rem;
      margin-bottom: 0.5rem;
      line-height: 1.25;
    }
  }

  .card-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
    margin-top: 0.75rem;
    margin-bottom: 0.5rem;
  }

  .card-company {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--color-link);
    background: linear-gradient(135deg, 
      var(--surface-glass) 0%, 
      var(--surface-glass-strong) 100%
    );
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    border: 1px solid var(--color-border);
    box-shadow: 
      0 2px 8px rgba(0, 0, 0, 0.04),
      0 0 0 1px rgba(0, 0, 0, 0.02) inset;
    transition: all 250ms ease;
  }
  
  .card-active .card-company {
    transform: translateY(0);
  }
  
  .dark .card-company {
    box-shadow: 
      0 2px 8px rgba(0, 0, 0, 0.2),
      0 0 0 1px rgba(255, 255, 255, 0.03) inset;
  }

  .card-period {
    font-size: 1rem;
    color: var(--color-muted);
    font-weight: 500;
  }

  .card-location {
    font-size: 1rem;
    color: var(--color-muted);
    font-weight: 500;
  }

  .card-description {
    font-size: 1.125rem;
    color: var(--color-muted);
    line-height: 1.6;
    margin: 0 0 1.5rem 0;
    flex: 1;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
    /* Prevent text blurriness during hover */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Mobile responsive description adjustments */
  @media (max-width: 768px) {
    .card-description {
      font-size: 0.9375rem;
      line-height: 1.5;
      margin-bottom: 0.875rem;
      -webkit-line-clamp: 3;
    }
  }

  @media (max-width: 480px) {
    .card-description {
      font-size: 0.875rem;
      line-height: 1.45;
      margin-bottom: 0.625rem;
      -webkit-line-clamp: 2;
    }
  }


  .card-stack-indicator {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background-color: var(--surface-glass);
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--color-muted);
    backdrop-filter: blur(8px);
  }

  .stack-count {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .stack-count::before {
    content: "📚";
    font-size: 0.875rem;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .card-stack-wrapper {
      padding: 0;
      gap: 1.5rem;
    }

    .card-company {
      font-size: 0.9375rem;
      padding: 0.4rem 0.75rem;
    }

    .card-period,
    .card-location {
      font-size: 0.875rem;
    }

    .card-nav-btn {
      width: 50px;
      height: 50px;
    }

    .card-dots {
      padding: 0.45rem 0.625rem;
      gap: 0.4rem;
    }

    .card-dot {
      width: 7px;
      height: 7px;
    }

    .card-dot.active {
      width: 20px;
    }

    .card-nav-controls {
      gap: 1.25rem;
      margin-top: -25px;
    }
  }

  @media (max-width: 480px) {
    .card-stack-wrapper {
      padding: 0;
      gap: 1.5rem;
    }

    .card-company {
      font-size: 0.875rem;
      padding: 0.35rem 0.65rem;
    }

    .card-period,
    .card-location {
      font-size: 0.8125rem;
    }

    .card-nav-btn {
      width: 46px;
      height: 46px;
    }

    .card-nav-btn svg {
      width: 22px;
      height: 22px;
    }

    .card-dots {
      padding: 0.4rem 0.5rem;
      gap: 0.35rem;
    }

    .card-dot {
      width: 6px;
      height: 6px;
    }

    .card-dot.active {
      width: 18px;
    }

    .card-nav-controls {
      gap: 1rem;
      margin-top: -20px;
    }
  }

  /* Extra small screens */
  @media (max-width: 360px) {
    .card-company {
      font-size: 0.9rem;
      padding: 0.3rem 0.6rem;
    }

    .card-period,
    .card-location {
      font-size: 0.85rem;
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .card {
      transition: opacity var(--transition-duration) ease;
    }
    
    .card-content {
      transition: box-shadow var(--transition-duration) ease;
    }
  }
</style>
