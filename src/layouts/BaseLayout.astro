---
import "../styles/global.css";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import Background from "../components/Background.astro";
import Analytics from '@vercel/analytics/astro';

interface Props {
  title?: string;
  description?: string;
  ogImage?: string;
}
const {
  title = "Bryan Jacinto - Copywriter & SEO",
  description = "UX & SEO writing portfolio.",
  ogImage,
} = Astro.props;
const url = Astro.url?.href ?? "";
---
<!doctype html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <script>
      document.documentElement.classList.add('js');
    </script>

    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-chrome-192x192.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="/favicon/android-chrome-512x512.png" />
    <link rel="shortcut icon" href="/favicon/favicon.ico" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <link rel="canonical" href={url} />
    
    <!-- Preload LCP image for faster loading -->
    <link rel="preload" as="image" href="/Bryan_hero_image.webp" fetchpriority="high" />

    <!-- SEO Meta Tags -->
    <meta name="author" content="Bryan Jacinto" />
    <meta name="keywords" content="copywriter, SEO, content strategy, web development, B2B content, technical writing" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content={url} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    {ogImage && <meta property="og:image" content={ogImage} />}
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content={url} />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    {ogImage && <meta name="twitter:image" content={ogImage} />}

    <!-- Fonts: Inter (variable) - Optimized loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300..800&display=swap"
      rel="stylesheet"
      media="print" onload="this.media='all'"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,300..700&display=swap"
      rel="stylesheet"
      media="print" onload="this.media='all'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300..800&display=swap"
        rel="stylesheet"
      />
      <link
        href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,300..700&display=swap"
        rel="stylesheet"
      />
    </noscript>

    <!-- Inline critical CSS for immediate render -->
    <style>
      /* Critical above-the-fold styles */
      :root {
        --color-bg: #ffffff;
        --color-text: #212529;
        --color-heading: #000000;
        --header-bg: #212529;
      }
      .dark {
        --color-bg: #000000;
        --color-text: #ffffff;
        --color-heading: #ffffff;
      }
      html { font-family: Inter, ui-sans-serif, system-ui, Arial, sans-serif; }
      body { 
        min-height: 100svh;
        background-color: var(--color-bg);
        color: var(--color-text);
        margin: 0;
      }
      * { transition: none !important; }
    </style>

    <!-- Early theme apply to avoid FOUC (no transitions on load) -->
    <script>
      (() => {
        // Temporarily disable transitions
        const style = document.createElement('style');
        style.textContent = '* { transition: none !important; }';
        document.head.appendChild(style);
        
        // Apply theme
        const ls = localStorage.getItem("theme");
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        document.documentElement.classList.toggle(
          "dark",
          ls === "dark" || (!ls && prefersDark)
        );
        
        // Re-enable transitions after a brief moment
        setTimeout(() => style.remove(), 0);
      })();
    </script>
  </head>

  <!-- Normal document flow; viewport scroll bar stays as-is -->
  <body class="antialiased min-h-svh">
    <!-- Site-wide layered background (z-0) -->
    <Background />

    <!-- Header is sticky (defined in Header.astro) -->
    <Header />

    <!-- ScrollSmoother wrapper -->
    <div id="smooth-wrapper">
      <div id="smooth-content" class="relative z-10 flex min-h-svh flex-col pt-[88px]">
        <!-- Page content scrolls with the viewport -->
        <main id="content" class="relative z-10 flex-1">
          <slot />
        </main>

        <!-- Footer is NOT sticky -->
        <div class="relative z-10">
          <Footer />
        </div>
      </div>
    </div>
    
    <!-- Vercel Analytics -->
    <Analytics />

    <script type="module">
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

      const init = async () => {
        if (prefersReducedMotion.matches) {
          const existing = window.__scrollSmoother;
          if (existing) {
            existing.kill();
            window.__scrollSmoother = undefined;
          }
          return;
        }

        try {
          const [{ gsap }, { ScrollTrigger }, { ScrollSmoother }] = await Promise.all([
            import('gsap'),
            import('gsap/ScrollTrigger'),
            import('gsap/ScrollSmoother'),
          ]);

          gsap.registerPlugin(ScrollTrigger, ScrollSmoother);

          const existing = ScrollSmoother.get();
          if (existing) existing.kill();

          const smoother = ScrollSmoother.create({
            wrapper: '#smooth-wrapper',
            content: '#smooth-content',
            smooth: 1,
            smoothTouch: 0.1,
            effects: true,
            normalizeScroll: true,
          });

          window.__scrollSmoother = smoother;
        } catch (error) {
          console.warn('ScrollSmoother failed to initialize', error);
        }
      };

      const start = () => {
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
          init();
        } else {
          window.addEventListener('DOMContentLoaded', init, { once: true });
        }
      };

      start();

      prefersReducedMotion.addEventListener('change', (event) => {
        if (event.matches) {
          const existing = window.__scrollSmoother;
          if (existing) {
            existing.kill();
            window.__scrollSmoother = undefined;
          }
        } else {
          init();
        }
      });

      document.addEventListener('click', (event) => {
        const target = event.target;
        if (!(target instanceof Element)) return;

        const trigger = target.closest('[data-scroll-to]');
        if (!trigger) return;

        const selector = trigger.getAttribute('data-scroll-to');
        if (!selector) return;

        const smoother = window.__scrollSmoother;
        const element = document.querySelector(selector);
        if (!element) return;

        event.preventDefault();

        const position = trigger.getAttribute('data-scroll-position') ?? 'top top';
        const offsetAttr = trigger.getAttribute('data-scroll-offset');
        const offsetValue = offsetAttr ? parseFloat(offsetAttr) : null;

        if (smoother) {
          if (Number.isFinite(offsetValue)) {
            const targetPosition = smoother.offset(element, position) - (offsetValue ?? 0);
            smoother.scrollTo(targetPosition, true);
          } else {
            smoother.scrollTo(element, true, position);
          }
        } else if (Number.isFinite(offsetValue)) {
          const rect = element.getBoundingClientRect();
          const top = window.scrollY + rect.top - (offsetValue ?? 0);
          window.scrollTo({ top, behavior: 'smooth' });
        } else {
          element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      });
    </script>
    <script>
      (() => {
        const processedAttr = 'data-external-link-handled';
        const origin = window.location.origin;

        const ensureRel = (anchor) => {
          const rel = anchor.getAttribute('rel');
          const tokens = new Set((rel || '').split(/\s+/).filter(Boolean));
          tokens.add('noopener');
          tokens.add('noreferrer');
          anchor.setAttribute('rel', Array.from(tokens).join(' '));
        };

        const handleAnchor = (anchor) => {
          if (!(anchor instanceof HTMLAnchorElement)) return;
          if (anchor.hasAttribute(processedAttr)) return;

          const href = anchor.getAttribute('href');
          if (!href || href.startsWith('#') || href.startsWith('mailto:') || href.startsWith('tel:')) {
            return;
          }

          try {
            const url = new URL(href, window.location.href);
            if (url.origin === origin) return;
          } catch {
            return;
          }

          if (!anchor.getAttribute('target')) {
            anchor.setAttribute('target', '_blank');
          }
          ensureRel(anchor);
          anchor.setAttribute(processedAttr, 'true');
        };

        const processAllAnchors = () => {
          document.querySelectorAll('a').forEach(handleAnchor);
        };

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', processAllAnchors, { once: true });
        } else {
          processAllAnchors();
        }

        const observer = new MutationObserver((mutations) => {
          for (const { addedNodes } of mutations) {
            addedNodes.forEach((node) => {
              if (node.nodeType !== Node.ELEMENT_NODE) return;
              if (node.matches?.('a')) {
                handleAnchor(node);
              }
              node.querySelectorAll?.('a').forEach(handleAnchor);
            });
          }
        });

        if (document.body) {
          observer.observe(document.body, { childList: true, subtree: true });
        } else {
          document.addEventListener('DOMContentLoaded', () => {
            observer.observe(document.body, { childList: true, subtree: true });
          }, { once: true });
        }
      })();
    </script>
  </body>
</html>

